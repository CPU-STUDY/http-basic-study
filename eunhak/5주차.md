# HTTP 헤더 2 - 캐시와 조건부 요청




## 캐시 기본 동작

### 캐시가 없을 때

#### 첫번 째 요청
![image](https://user-images.githubusercontent.com/95483959/188263837-47d15fb3-4f9a-4590-b400-368476d526c8.png)

이때 응답이 1.1mb라고 해보자.

#### 두 번째 요청

![image](https://user-images.githubusercontent.com/95483959/188263847-124a6f48-b441-4782-9d26-df69ada82ce1.png)

똑같이 응답이 1.1mb

데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.

인터넷 네트워크는 PC 메모리나 하드디스크에 비해 매우 느리고 비싸다.

브라우저 로딩속도가 느리다 -> 느린 사용자 경험


### 캐시 적용


#### 첫 번째 요청


![image](https://user-images.githubusercontent.com/95483959/188263855-b34b5aa8-6e3f-4f6b-a483-2b24c36eac53.png)
 

이때 응답 헤더 필드에

cache-control: max-age=60 (캐시가 유효한 시간 - 초)

1.1mb 응답. 이 응답 결과를 브라우저 캐시 저장소에 저장(60초 동안)

#### 두 번째 요청  

우선 캐시를 탐색 -> 캐시 유효시간 내라면 네트워크 이용하지 않고 캐시를 이용

캐시 덕분에 캐시 가능 시간 동안 네트워크를 사용하지 않아도 되고 비싼 네트워크 사용량을 줄일 수 있다.

브라우저 로딩 속도가 매우 빠르다. -> 빠른 사용자 경험

#### 세 번째 요청 - 캐시 시간 초과

캐시를 탐색 -> 유효시간 끝나 -> 네트워크 이용해서 다시 요청 -> 다시 응답 받아서 기존 거 지우고 새로 저장

캐시 유효시간이 초과하면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다.

이때 다시 네트워크 다운로드가 발생


## 검증 헤더와 조건부 요청 1


캐시 시간 초과

캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 있을 수 있다.

#### 1.서버에서 기존 데이터를 변경함
#### 2.서버에서 기존 데이터를 변경하지 않음
#### ->2번의 경우에는 네트워크를 쓰는 게 낭비.

캐시 만료 후에도 서버에서 데이터를 변경하지 않았을 때

데이터를 전송하는 대신에 저장해둔 캐시를 재사용할 수 있다.

단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

그때 사용 하는 게 검증헤더다.

첫 번째 요청 때 응답 헤더에

![image](https://user-images.githubusercontent.com/95483959/188263821-4b21c46e-ac64-436d-8a5d-a780c5cd2731.png)


위와 같이 추가하고

응답 결과를 캐시에 저장한다.

두 번째 요청 때 캐시시간 초과했다면

요청을 다시 보낼 때 last-modifed가 있으면

요청 헤더에

![image](https://user-images.githubusercontent.com/95483959/188263933-580d92e9-4d8a-48e4-94c7-773d015b6d8d.png)


서버가 이걸 확인한 다음. 데이터 수정시간과 if-modified-since를 비교해서 데이터가 변하지 않았다고 판단한 뒤

304 Not Modified 라는 상태코드를 응답한다.

이때, cache-contral, last-modified그대로 가는데

메세지 바디가 없음.

헤더가 0.1m, 바디가 1.0m이라고 하면 1m를 아낄 수 있음

클라이언트는 이 응답을 확인해서 캐시 저장소에 있는 데이터의 cache-control 갱신 -> 그 다음부터 다시 캐시 사용

Last-modified는 검증헤더고, if-modified-since는 조건부 요청이다.

### 정리
캐시 유효 시간이 초과해도 서버의 데이터가 갱신되지 않으면

304 Not Modified + 헤더 메타 정보만 응답(바디 안 줘)

클라는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신

클라는 캐시에 저장되어 있는 데이터 재활용

결과적으로 네트워크 다운로드가 발생은 하지만 용량이 적은 헤더 정보만 다운로드

매우 실용적인 해결책

